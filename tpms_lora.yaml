esphome:
  name: tpmslora
  includes:
    tpms.h
  platformio_options:
    board_build.f_cpu: 80000000L

esp32:
  board: lolin_s2_mini
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80: y
      
wifi:
#  networks:
#  - ssid: !secret wifi_ssid_home1 
#    password: !secret wifi_password_home1
#  - ssid: !secret wifi_ssid_my_home2
#    password: !secret wifi_password_my_home2
  ap:
    ssid: "TPMS"
    password: "12345678"
  reboot_timeout: 0s

logger:
  hardware_uart: USB_CDC

# Enable Home Assistant API
api:
  reboot_timeout: 0s

# Make sure you can upload new firmware OTA
ota:
  platform: esphome

globals:
  - id: lastdata
    type: int
    restore_value: no
    initial_value: '-1'

web_server:
  port: 80
  local: true
  version: 3
  sorting_groups:
    - id: sorting_group1
      name: "Out sensors"
      sorting_weight: -10

status_led:
  pin:
    number: GPIO15
    inverted: false

spi:
  clk_pin: GPIO6
  mosi_pin: GPIO10
  miso_pin: GPIO8

sx127x:
  id: sx1276
  data_rate: 5MHz #SPI data_rate
  cs_pin: GPIO13
  rst_pin: GPIO17
  dio0_pin: GPIO21
  pa_pin: BOOST
  pa_power: 4
  bandwidth: 200_0kHz
  frequency: 433.92MHz
  bitrate: 19200
  preamble_detect: 2
  preamble_size: 4
  preamble_errors: 0
  preamble_polarity: 0x55
  sync_value: [0x55, 0x56]
  modulation: FSK
  deviation: 40kHz
  packet_mode: true
  payload_length: 16
  rx_start: true
  bitsync: true
  crc_enable: false
  on_packet:
    then:
      - lambda: |-
          ESP_LOGD("tpms", "packet %s", format_hex(x).c_str());
          TPMS::tpms td;
          static TPMS::tpms pretd;

          if (TPMS::decode_manchester_ge_thomas((char*)td.data, (const char*)x.data(), 8) != 0 )
            return;

          if (memcmp(pretd.data, td.data, 7) == 0) //повтор
            return;

          if (TPMS::Crc8Block(0, td.data, 7) == td.crc)
          {
            id(lastdata)++;
            ESP_LOGI("tpms", "%3d id %02X%02X%02X%02X, %.0f kPa, %.0f °C, %02X, crc: %02X", id(lastdata), td.id[0],td.id[1],td.id[2],td.id[3], (float)to_kpa(td.pressure), (float)td.temperature - 50, td.flags, td.crc );
            memcpy(pretd.data, td.data, 8);
            
            //ПОДМЕНА датчиков
            char data[16];
            uint8_t sensorid[4];

            esphome::parse_hex(id(sensor1in).state, sensorid, 4);            
            if (memcmp(sensorid, td.id, 4) == 0)
            {
              esphome::parse_hex(id(sensor1out).state, td.id, 4);
              id(sensor1p).publish_state((float)to_kpa(td.pressure));
              id(sensor1t).publish_state((float)td.temperature - 50);
              td.crc = TPMS::Crc8Block(0, td.data, 7);
              TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
              id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
            }

            esphome::parse_hex(id(sensor2in).state, sensorid, 4);            
            if (memcmp(sensorid, td.id, 4) == 0)
            {
              esphome::parse_hex(id(sensor2out).state, td.id, 4);
              id(sensor2p).publish_state((float)to_kpa(td.pressure));
              id(sensor2t).publish_state((float)td.temperature - 50);
              td.crc = TPMS::Crc8Block(0, td.data, 7);
              TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
              id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
            }

            esphome::parse_hex(id(sensor3in).state, sensorid, 4);            
            if (memcmp(sensorid, td.id, 4) == 0)
            {
              esphome::parse_hex(id(sensor3out).state, td.id, 4);
              id(sensor3p).publish_state((float)to_kpa(td.pressure));
              id(sensor3t).publish_state((float)td.temperature - 50);
              td.crc = TPMS::Crc8Block(0, td.data, 7);
              TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
              id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
            }

            esphome::parse_hex(id(sensor4in).state, sensorid, 4);            
            if (memcmp(sensorid, td.id, 4) == 0)
            {
              esphome::parse_hex(id(sensor4out).state, td.id, 4);
              id(sensor4p).publish_state((float)to_kpa(td.pressure));
              id(sensor4t).publish_state((float)td.temperature - 50);
              td.crc = TPMS::Crc8Block(0, td.data, 7);
              TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
              id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
            }
          }

text:
  - platform: template
    name: "Sensor 1 car"
    id: "sensor1out"
    update_interval: never
    optimistic: true
    min_length: 8
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '43baff48'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 10

  - platform: template
    name: "Sensor 1 tire"
    id: "sensor1in"
    update_interval: never
    optimistic: true
    min_length: 0
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '3c199818'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 11

  - platform: template
    name: "Sensor 2 car"
    id: "sensor2out"
    update_interval: never
    optimistic: true
    min_length: 8
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '43540bae'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 20

  - platform: template
    name: "Sensor 2 tire"
    id: "sensor2in"
    update_interval: never
    optimistic: true
    min_length: 0
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '3c19a924'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 21

  - platform: template
    name: "Sensor 3 car"
    id: "sensor3out"
    update_interval: never
    optimistic: true
    min_length: 8
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '4353fe41'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 30

  - platform: template
    name: "Sensor 3 tire"
    id: "sensor3in"
    update_interval: never
    optimistic: true
    min_length: 0
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '3c199871'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 31

  - platform: template
    name: "Sensor 4 car"
    id: "sensor4out"
    update_interval: never
    optimistic: true
    min_length: 8
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '4353fe4b'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 40

  - platform: template
    name: "Sensor 4 tire"
    id: "sensor4in"
    update_interval: never
    optimistic: true
    min_length: 0
    max_length: 8
    mode: text
    restore_value: true
    initial_value: '00992489'
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 41

number:
  - platform: template
    name: "Sensor 1 pressure"
    id: "sensor1p"
    update_interval: never
    optimistic: true
    min_value: 0
    max_value: 300
    step: 1
    unit_of_measurement: "кПа"
    mode: "box"
    restore_value: true
    initial_value: 201
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 12

  - platform: template
    name: "Sensor 2 pressure"
    id: "sensor2p"
    update_interval: never
    optimistic: true
    min_value: 0
    max_value: 300
    step: 1
    unit_of_measurement: "кПа"
    mode: "box"
    restore_value: true
    initial_value: 202
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 22

  - platform: template
    name: "Sensor 3 pressure"
    id: "sensor3p"
    update_interval: never
    optimistic: true
    min_value: 0
    max_value: 300
    step: 1
    unit_of_measurement: "кПа"
    mode: "box"
    restore_value: true
    initial_value: 203
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 32

  - platform: template
    name: "Sensor 4 pressure"
    id: "sensor4p"
    update_interval: never
    optimistic: true
    min_value: 0
    max_value: 300
    step: 1
    unit_of_measurement: "кПа"
    mode: "box"
    restore_value: true
    initial_value: 204
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 42

  - platform: template
    name: "Sensor 1 temperature"
    id: "sensor1t"
    update_interval: never
    optimistic: true
    min_value: -50
    max_value: 150
    step: 1
    unit_of_measurement: "°C"
    mode: "box"
    restore_value: true
    initial_value: -10
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 13

  - platform: template
    name: "Sensor 2 temperature"
    id: "sensor2t"
    update_interval: never
    optimistic: true
    min_value: -50
    max_value: 150
    step: 1
    unit_of_measurement: "°C"
    mode: "box"
    restore_value: true
    initial_value: -11
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 23

  - platform: template
    name: "Sensor 3 temperature"
    id: "sensor3t"
    update_interval: never
    optimistic: true
    min_value: -50
    max_value: 150
    step: 1
    unit_of_measurement: "°C"
    mode: "box"
    restore_value: true
    initial_value: -12
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 33

  - platform: template
    name: "Sensor 4 temperature"
    id: "sensor4t"
    update_interval: never
    optimistic: true
    min_value: -50
    max_value: 150
    step: 1
    unit_of_measurement: "°C"
    mode: "box"
    restore_value: true
    initial_value: -13
    web_server:
      sorting_group_id: sorting_group1
      sorting_weight: 43

button:
  - platform: template
    name: "TPMS Send"
    id: send_button
    on_press:
      then:
        - lambda: |-
            TPMS::tpms td;
            char data[16];
            esphome::parse_hex(id(sensor1out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor1p).state, (int)id(sensor1t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));

            esphome::parse_hex(id(sensor2out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor2p).state, (int)id(sensor2t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));

            esphome::parse_hex(id(sensor3out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor3p).state, (int)id(sensor3t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));

            esphome::parse_hex(id(sensor4out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor4p).state, (int)id(sensor4t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));

script:
  - id: send_tpms
    mode: queued
    parameters:
      packet: string
    then:
      - logger.log:
          format: "Send \"%s\"..."
          args: [ 'packet.c_str()' ]
      - delay: 50ms
      - sx127x.send_packet:
          data: !lambda |-
                    std::vector<uint8_t> data;
                    esphome::parse_hex(packet, data, 16);
                    return data;
      - delay: 100ms
      - sx127x.send_packet:
          data: !lambda |-
                    std::vector<uint8_t> data;
                    esphome::parse_hex(packet, data, 16);
                    return data;
      - delay: 100ms
      - sx127x.send_packet:
          data: !lambda |-
                    std::vector<uint8_t> data;
                    esphome::parse_hex(packet, data, 16);
                    return data;
      - delay: 100ms
      - sx127x.send_packet:
          data: !lambda |-
                    std::vector<uint8_t> data;
                    esphome::parse_hex(packet, data, 16);
                    return data;
      - delay: 500ms

interval: 
  - interval: 5min 
    then:
      - lambda: |-
          TPMS::tpms td;
          char data[16];
          if (id(sensor1in).state.length() < 8)
          {
            esphome::parse_hex(id(sensor1out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor1p).state, (int)id(sensor1t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
          }
          if (id(sensor2in).state.length() < 8)
          {
            esphome::parse_hex(id(sensor2out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor2p).state, (int)id(sensor2t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
          }
          if (id(sensor3in).state.length() < 8)
          {
            esphome::parse_hex(id(sensor3out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor3p).state, (int)id(sensor3t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
          }
          if (id(sensor4in).state.length() < 8)
          {
            esphome::parse_hex(id(sensor4out).state, td.id, 4);
            TPMS::tpms_coolray(&td, td.id, (int)id(sensor4p).state, (int)id(sensor4t).state);
            TPMS::encode_manchester_ge_thomas(data, (const char*) td.data, 8);
            id(send_tpms)->execute(esphome::format_hex((const uint8_t *)data, 16));
          }

sensor:
  - platform: internal_temperature
    name: ESP Temperature
    entity_category: "diagnostic"
  - platform: uptime
    name: Uptime
    id: sys_uptime
#  - platform: wifi_signal 
#    name: WiFi RSSI
#    id: wifi_signal_db

binary_sensor:
  - platform: gpio
    name: "Onboard Button"
    pin:
      number: GPIO0
      inverted: true
      mode:
        input: true
        pullup: true
    on_press:
      then:
        - button.press: send_button
